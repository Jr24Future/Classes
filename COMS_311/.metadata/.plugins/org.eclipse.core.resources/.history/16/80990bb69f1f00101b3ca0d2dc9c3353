package coms3110.hw4;

import java.util.*;

public class WeightedAdjacencyList<T> implements WeightedGraph<T> {
    private final Map<T, List<Pair<T, Integer>>> adjList;
    
    public WeightedAdjacencyList(List<T> vertices) {
        adjList = new HashMap<>();
        for (T vertex : vertices) {
            adjList.put(vertex, new ArrayList<>());
        }
    }
    /**
     * Adds the directed edge (u,v) to the graph. If the edge is already present, it should not be modified.
     * @param u The source vertex.
     * @param v The target vertex.
     * @param weight The weight of the edge (u,v).
     * @return True if the edge was added to the graph, false if 1) either u or v are not in the graph 2) the edge was already present.
     */
    @Override
    public boolean addEdge(T u, T v, int weight) {
        if (!adjList.containsKey(u) || !adjList.containsKey(v)) return false;

        List<Pair<T, Integer>> neighbors = adjList.get(u);
        for (Pair<T, Integer> pair : neighbors) {
            if (pair.getFirst().equals(v)) return false; // already exists
        }
        neighbors.add(new Pair<>(v, weight));
        return true;
    }

    /**
     * @param vertex A vertex to add to the graph.
     * @return False vertex was already in the graph, true otherwise.
     */
    @Override
    public boolean addVertex(T vertex) {
        if (adjList.containsKey(vertex)) return false;
        adjList.put(vertex, new ArrayList<>());
        return true;
    }

    /**
     * @return |V|
     */
    @Override
    public int getVertexCount() {
        return adjList.size();
    }

    /**
     * @param v The name of a vertex.
     * @return True if v is in the graph, false otherwise.
     */
    @Override
    public boolean hasVertex(T v) {
        return adjList.containsKey(v);
    }

    /**
     * @return An Iterable of V.
     */
    @Override
    public Iterable<T> getVertices() {
        return adjList.keySet();
    }

    /**
     * @return |E|
     */
    @Override
    public int getEdgeCount() {
        int count = 0;
        for (List<Pair<T, Integer>> neighbors : adjList.values()) {
            count += neighbors.size();
        }
        return count;
    }

    /**
     * @param u The source of the edge.
     * @param v The target of the edge.
     * @return True if (u,v) is in the graph, false otherwise.
     */
    @Override
    public boolean hasEdge(T u, T v) {
        if (!adjList.containsKey(u)) return false;
        for (Pair<T, Integer> pair : adjList.get(u)) {
            if (pair.getFirst().equals(v)) return true;
        }
        return false;
    }

    /**
     * @param u A vertex.
     * @return The neighbors of u in the weighted graph.
     */
    @Override
    public Iterable<T> getNeighbors(T u) {
        List<T> result = new ArrayList<>();
        if (!adjList.containsKey(u)) return result;
        for (Pair<T, Integer> pair : adjList.get(u)) {
            result.add(pair.getFirst());
        }
        return result;
    }

    /**
     * @param u
     * @param v
     * @return
     */
    @Override
    public boolean areNeighbors(T u, T v) {
        return hasEdge(u,v);
    }

    /**
     * Uses Dijkstra's algorithm to find the (length of the) shortest path from s to all other reachable vertices in the graph.
     * If the graph contains negative edge weights, the algorithm should terminate, but the return value is undefined.
     * @param s The source vertex.
     * @return A Mapping from all reachable vertices to their distance from s. Unreachable vertices should NOT be included in the Map.
     */
    @Override
    public Map<T, Long> getShortestPaths(T s) {
        Map<T, Long> dist = new HashMap<>();
        PriorityQueue<Pair<T, Long>> pq = new PriorityQueue<>(Comparator.comparingLong(Pair::getSecond));
        Set<T> visited = new HashSet<>();

        dist.put(s, 0L);
        pq.offer(new Pair<>(s, 0L));

        while (!pq.isEmpty()) {
            Pair<T, Long> current = pq.poll();
            T u = current.getFirst();

            if (visited.contains(u)) continue;
            visited.add(u);

            for (Pair<T, Integer> neighbor : adjList.getOrDefault(u, List.of())) {
                T v = neighbor.getFirst();
                int weight = neighbor.getSecond();
                long alt = dist.get(u) + weight;

                if (!dist.containsKey(v) || alt < dist.get(v)) {
                    dist.put(v, alt);
                    pq.offer(new Pair<>(v, alt));
                }
            }
        }

        return dist;
    }
}
