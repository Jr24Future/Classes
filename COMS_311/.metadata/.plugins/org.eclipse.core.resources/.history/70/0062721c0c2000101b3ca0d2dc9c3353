package cs3110.hw4;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.IntStream;




public class CharacterSeparator {
    /**
     * This method uses the WeightedAdjacencyList class to identify the space between characters in an image of text.
     * For efficiency, it should only construct a single graph object and should only make a constant
     * number of calls to Dijkstra's algorithm.
     * @param path The location of the image on disk.
     * @return Two lists of Integer. The first list indicates whitespace rows. The second list indicates whitespace columns. Returns null if some error occurred loading the image.
     */
	public static Pair<List<Integer>, List<Integer>> findSeparationWeighted(String path) {
	    try {
	        BitmapProcessor bp = new BitmapProcessor(path);
	        int[][] pixels = bp.getRGBMatrix();

	        WeightedAdjacencyList<String> graph = createGraphFromPixels(pixels);
	        List<Integer> whitespaceRows = WhitespaceRows(graph, pixels);
	        List<Integer> whitespaceCols = WhitespaceCols(graph, pixels);

	        return new Pair<>(whitespaceRows, whitespaceCols);
	    } catch (IOException e) {
	        System.err.println("Failed to load image: " + e.getMessage());
	        return null;
	    }
	}
   
    /**
     * Converts a 2D pixel matrix into a graph of pixels.
     */
    private static WeightedAdjacencyList<String> createGraphFromPixels(int[][] pixels) {
        int height = pixels.length;
        int width = pixels[0].length;

        List<String> vertices = new ArrayList<>();
        // Create graph vertices
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                vertices.add(i + "," + j);
            }
        }

        WeightedAdjacencyList<String> graph = new WeightedAdjacencyList<>(vertices);
        // Add weighted edges based on neighbor brightness
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                String from = i + "," + j;
                if (i > 0) addEdge(graph, from, (i - 1) + "," + j, pixels[i - 1][j]);
                if (i < height - 1) addEdge(graph, from, (i + 1) + "," + j, pixels[i + 1][j]);
                if (j > 0) addEdge(graph, from, i + "," + (j - 1), pixels[i][j - 1]);
                if (j < width - 1) addEdge(graph, from, i + "," + (j + 1), pixels[i][j + 1]);
            }
        }

        return graph;
    }

    /**
     * Adds a weighted edge based on pixel brightness.
     */
    private static void addEdge(WeightedAdjacencyList<String> graph, String from, String to, int pixelValue) {
        int weight = (pixelValue == 0xFFFFFFFF) ? 1 : 1000;
        graph.addEdge(from, to, weight);
    }
    
    /**
     * Identifies whitespace rows by finding low-cost horizontal paths.
     */
    private static List<Integer> WhitespaceRows(WeightedAdjacencyList<String> graph, int[][] pixels) {
        List<Integer> whiteRows = new ArrayList<>();
        int height = pixels.length;
        int width = pixels[0].length;

        List<Long> allCosts = new ArrayList<>();
        Map<Integer, Long> rowToCost = new HashMap<>();

        for (int i = 0; i < height; i++) {
            String left = i + ",0";
            String right = i + "," + (width - 1);
            Map<String, Long> dist = graph.getShortestPaths(left);
            Long cost = dist.get(right);
            if (cost != null) {
                allCosts.add(cost);
                rowToCost.put(i, cost);
            }
        }

        allCosts.sort(Long::compareTo);
        int percentileIndex = (int) (allCosts.size() * 0.2);
        long threshold = allCosts.get(Math.min(percentileIndex, allCosts.size() - 1));

        for (Map.Entry<Integer, Long> entry : rowToCost.entrySet()) {
            if (entry.getValue() <= threshold) {
                whiteRows.add(entry.getKey());
            }
        }

        Collections.sort(whiteRows);
        return whiteRows;
    }

    /**
     * Identifies whitespace columns by finding low-cost vertical paths.
     */
    private static List<Integer> WhitespaceCols(WeightedAdjacencyList<String> graph, int[][] pixels) {
        List<Integer> whiteCols = new ArrayList<>();
        int height = pixels.length;
        int width = pixels[0].length;

        List<Long> allCosts = new ArrayList<>();
        Map<Integer, Long> colToCost = new HashMap<>();

        for (int j = 0; j < width; j++) {
            String top = "0," + j;
            String bottom = (height - 1) + "," + j;
            Map<String, Long> dist = graph.getShortestPaths(top);
            Long cost = dist.get(bottom);
            if (cost != null) {
                allCosts.add(cost);
                colToCost.put(j, cost);
            }
        }

        allCosts.sort(Long::compareTo);
        int percentileIndex = (int) (allCosts.size() * 0.2);
        long threshold = allCosts.get(Math.min(percentileIndex, allCosts.size() - 1));

        for (Map.Entry<Integer, Long> entry : colToCost.entrySet()) {
            if (entry.getValue() <= threshold) {
                whiteCols.add(entry.getKey());
            }
        }

        Collections.sort(whiteCols);
        return whiteCols;
    }
    
    public static void visualizeSeparations(String inputPath) {
        try {
            System.out.println("Loading image from: " + inputPath);

            Pair<List<Integer>, List<Integer>> separations = findSeparationWeighted(inputPath);
            List<Integer> rowSeps = separations.getFirst();
            List<Integer> colSeps = separations.getSecond();

            BitmapProcessor processor = new BitmapProcessor(inputPath);
            BufferedImage image = processor.bi;
            int width = image.getWidth();
            int height = image.getHeight();

            System.out.println("Found " + rowSeps.size() + " row separations");
            System.out.println("Found " + colSeps.size() + " column separations");

            // Draw red lines on whitespace rows
            for (Integer row : rowSeps) {
                for (int x = 0; x < width; x++) {
                    image.setRGB(x, row, Color.RED.getRGB());
                }
            }

            // Draw green lines on whitespace columns
            for (Integer col : colSeps) {
                for (int y = 0; y < height; y++) {
                    image.setRGB(col, y, Color.GREEN.getRGB());
                }
            }

            processor.writeToFile();
            System.out.println("Saved processed image as: " + inputPath + ".new.bmp");

        } catch (IOException e) {
            System.out.println("Error processing image: " + e.getMessage());
        }
    }
    

}
