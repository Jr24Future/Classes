
#include "movement.h"
#include "open_interface.h"
#include "uart.h"
#include "Timer.h"
#include <math.h>

// MAKE SURE TO CALIBRATE EACH TIME YOU USE A DIFFERENT BOT HERE
//short cc_RWP = 50;            //Cybot 13
//short c_LWP = 42;
//short forward_RWP = 93;

//short cc_RWP = 67;            //Cybot 03
//short c_LWP = 40;
//short forward_RWP = 95;

//short cc_RWP = 66;            //Cybot 01
//short c_LWP = 40;
//short forward_RWP = 95;

short cc_RWP = 39;            //Cybot 07
short c_LWP = 45;
short forward_RWP = 89;



short current_status;  // combination of all different OI sensor checks - functions as a 16 bit status register
short previous_status; // status at time of previous oi_update

int obstacleFlag = 0; // Indicates if an obstacle was encountered


double toRadians(double degrees) {
    return (M_PI / 180.0) * degrees;
}

/*
 * Call everytime you use a different bot, and get those 3 values, put it in movement.c
 */
void calibrate_wheels(oi_t *sensor) // can run perfectly on treadmill, does not need to be on the ground
{
    move_forward(sensor, 150, 0);   // moves forward so bot can settle into consistent values
    turn_clockwise(sensor, 180); // turns 360 degrees, input is a char so 360 is out of bounds
    turn_clockwise(sensor, 180);
    turn_counter_clockwise(sensor, 180); // turns 360 degrees, input is a char so 360 is out of bounds
    turn_counter_clockwise(sensor, 180);

    lcd_printf("f_RWP= %d  c_LWP= %dcc_RWP= %d", forward_RWP, c_LWP, cc_RWP); // prints cleanly to LCD
}

float move_forward(oi_t *sensor, float input_centimeters, float adjustment_cm) {
    float mm_traveled = 0;
    float angle_deviated = 0;


    // Add the adjustment to the target distance
    float target_distance_mm = (input_centimeters + adjustment_cm) * 10;

    while (mm_traveled < target_distance_mm) { // Loop until target distance is reached
        oi_update(sensor);
        obstacle_check(sensor); // Handle obstacles dynamically

        if (obstacleFlag == 1){
            obstacleFlag = 0;
            move_forward(sensor, 20, 0);


        }
        float distance_this_step = sensor->distance; // Get the distance traveled in this step
        mm_traveled += distance_this_step;          // Increment total distance traveled
        angle_deviated += sensor->angle;            // Track deviation

        update_live_position(distance_this_step);   // Update live position

        // Dynamic wheel adjustments to maintain straight line
        if (angle_deviated > degree_accuracy) { // Correct for veering left
            forward_RWP -= 1; // Reduce right wheel power
            angle_deviated = 0; // Reset angle deviation
        } else if (angle_deviated < -degree_accuracy) { // Correct for veering right
            forward_RWP += 1; // Increase right wheel power
            angle_deviated = 0; // Reset angle deviation
        }

        oi_setWheels(forward_RWP, forward_LWP); // Set wheel speeds
        timer_waitMillis(50); // Small delay for stability
    }

    oi_setWheels(0, 0); // Stop the robot
    return mm_traveled / 10; // Return total distance traveled in cm
}







void update_live_position(float distance_mm) {
    static float accumulated_distance = 0; // Keeps track of accumulated distance
    accumulated_distance += distance_mm;   // Add distance increment to the accumulator

    // Update position only when accumulated distance is significant
    if (fabs(accumulated_distance) >= 10.0) { // Threshold = 10 mm = 1 cm
        int delta = (int)(accumulated_distance / 10); // Convert mm to cm
        accumulated_distance -= delta * 10;          // Subtract the processed distance

        if ((current_orientation >= 330 || current_orientation <= 30)) { // North
            current_x -= delta;
        } else if (current_orientation >= 150 && current_orientation <= 210) { // South
            current_x += delta;
        } else if (current_orientation >= 60 && current_orientation <= 120) { // East
            current_y -= delta;
        } else if (current_orientation >= 240 && current_orientation <= 300) { // West
            current_y += delta;
        }

        // Debugging: Print updated position
        char debug_msg[100];
        sprintf(debug_msg, "Updated Position: (%d, %d), Heading: %d\n", current_x, current_y, current_orientation);
        uart_sendStr(debug_msg);


        // Display on LCD
        lcd_printf("Loc: (%d, %d)\nHeading: %d°", current_x, current_y, current_orientation);
    }
}



float move_backward(oi_t *sensor, float input_centimeters) {
    float mm_traveled = 0;
    float angle_deviated = 0;

    while (fabs(mm_traveled) < (input_centimeters * 10)) { // Loop until target distance is reached
        oi_update(sensor);
        // obstacle_check(sensor); // Uncomment if necessary

        mm_traveled += sensor->distance; // Increment distance traveled
        angle_deviated += sensor->angle; // Track deviation
        update_live_position(-fabs(sensor->distance)); // Use negative to indicate backward movement

        // Dynamic wheel adjustments to maintain straight line
        if (angle_deviated > degree_accuracy) { // Correct for veering left
            forward_RWP += 1; // Increase right wheel power
            angle_deviated = 0; // Reset angle deviation
        } else if (angle_deviated < -degree_accuracy) { // Correct for veering right
            forward_RWP -= 1; // Decrease right wheel power
            angle_deviated = 0; // Reset angle deviation
        }

        oi_setWheels(-forward_RWP, -forward_LWP); // Set wheel speeds for reverse
        timer_waitMillis(50); // Small delay for stability
    }

    oi_setWheels(0, 0); // Stop the robot
    return mm_traveled / 10; // Return total distance traveled in cm
}



int turn_clockwise(oi_t *sensor, double input_angle)  //input positive angle
{
    double angle_deviated = 0;  // Accumulate the angle turned
        double mm_deviated = 0;     // Track the movement distance (optional)
    // Adjust for calibration
    if (input_angle == 90) {
        input_angle = 86.5;
        angle_deviated = 3.5;
    } else if (input_angle == 45) {
        input_angle = 43.25;
        angle_deviated = 1.75;
    } else if (input_angle == 180) {
        input_angle = 173;
        angle_deviated = 7;
    } else {
        uart_sendStr("Unsupported angle for clockwise turn.\n");
        return -1;  // Unsupported angle
    }


    oi_setWheels(-50, 50); // Start turning clockwise
    while (angle_deviated < input_angle) {
        oi_update(sensor);  // Update sensor data
        angle_deviated -= sensor->angle;  // Add to total angle deviated
        mm_deviated += fabs(sensor->distance);  // Optionally track distance traveled
    }
    oi_setWheels(0, 0); // Stop turning

    // Debugging information
    char debug_msg[100];
    sprintf(debug_msg, "Clockwise Turn: Angle = %.2f, Distance = %.2f mm\n", angle_deviated, mm_deviated);
    uart_sendStr(debug_msg);

    return (int)angle_deviated;  // Return the total angle deviated
}


int turn_counter_clockwise(oi_t *sensor, double input_angle)  //input positive angle
{
    // Adjust for calibration
    if (input_angle == 90) {
        input_angle = 86.5;
    } else if (input_angle == 45) {
        input_angle = 43.25;
    } else if (input_angle == 180) {
        input_angle = 173;
    } else {
        uart_sendStr("Unsupported angle for counter-clockwise turn.\n");
        return -1;  // Unsupported angle
    }

    double angle_deviated = 0;  // Accumulate the angle turned
    double mm_deviated = 0;     // Track the movement distance (optional)

    oi_setWheels(50, -50); // Start turning counter-clockwise
    while (angle_deviated < input_angle) {
        oi_update(sensor);  // Update sensor data
        angle_deviated += sensor->angle;  // Add to total angle deviated
        mm_deviated += fabs(sensor->distance);  // Optionally track distance traveled
    }
    oi_setWheels(0, 0); // Stop turning

    // Debugging information
    char debug_msg[100];
    sprintf(debug_msg, "Counter-Clockwise Turn: Angle = %.2f, Distance = %.2f mm\n", angle_deviated, mm_deviated);
    uart_sendStr(debug_msg);

    return (int)angle_deviated;  // Return the total angle deviated
}



int turn(oi_t *sensor, double input_angle) {
    double angle_deviated = 0;

    // Normalize angle to [-180, 180]
    if (input_angle > 180) input_angle -= 360;
    if (input_angle < -180) input_angle += 360;

    if (input_angle > 0) { // Counterclockwise turn
        angle_deviated = turn_counter_clockwise(sensor, input_angle);
    } else if (input_angle < 0) { // Clockwise turn
        angle_deviated = turn_clockwise(sensor, -input_angle);
    } else {
        oi_setWheels(0, 0); // No turn required
    }

    // Update orientation
    current_orientation = (int)(current_orientation + angle_deviated + 360) % 360;

    // Debugging
    char debug_msg[100];
    sprintf(debug_msg, "Turn Input: %.2f°, Angle Deviated: %.2f°, New Orientation: %.2f°\n",
            input_angle, angle_deviated, current_orientation);
    uart_sendStr(debug_msg);

    return angle_deviated;
}



void obstacle_check(oi_t *sensor) {
    if (sensor->bumpRight) {
        move_backward(sensor, 15); // Automatically updates live position
        turn(sensor, 90);          // Turn right
        move_forward(sensor, 20, 0); // Move forward to bypass obstacle
        turn(sensor, -90);         // Turn back to original orientation
        obstacleFlag = 1;
    } else if (sensor->bumpLeft) {
        move_backward(sensor, 15); // Automatically updates live position
        turn(sensor, -90);         // Turn left
        move_forward(sensor, 20, 0); // Move forward to bypass obstacle
        turn(sensor, 90);          // Turn back to original orientation
        obstacleFlag = 1;
        }





    // Additional checks for cliffs or borders (if required):
    /*else if (sensor->cliffLeft) {
        current_status |= cliff_left;
        uart_sendStr("Cliff: Left\n");
        move_backward(sensor, 15);
        update_live_position(-15);
    }

    else if (sensor->cliffFrontLeft) {
        current_status |= cliff_front_left;
        uart_sendStr("Cliff: Front Left\n");
        move_backward(sensor, 15);
        update_live_position(-15);
    }

    else if (sensor->cliffRight) {
        current_status |= cliff_right;
        uart_sendStr("Cliff: Right\n");
        move_backward(sensor, 15);
        update_live_position(-15);
    }

    else if (sensor->cliffFrontRight) {
        current_status |= cliff_front_right;
        uart_sendStr("Cliff: Front Right\n");
        move_backward(sensor, 15);
        update_live_position(-15);
    }

    // Check for WHITE border
    else if (sensor->cliffLeftSignal > 2700) {
        current_status |= border_left;
        uart_sendStr("Border: Left\n");
        move_backward(sensor, 15);
        update_live_position(-15);
    }

    else if (sensor->cliffFrontLeftSignal > 2700) {
        current_status |= border_front_left;
        uart_sendStr("Border: Front Left\n");
        move_backward(sensor, 15);
        update_live_position(-15);
    }

    else if (sensor->cliffRightSignal > 2700) {
        current_status |= border_right;
        uart_sendStr("Border: Right\n");
        move_backward(sensor, 15);
        update_live_position(-15);
    }

    else if (sensor->cliffFrontRightSignal > 2700) {
        current_status |= border_front_right;
        uart_sendStr("Border: Front Right\n");
        move_backward(sensor, 15);
        update_live_position(-15);
    }*/
}




