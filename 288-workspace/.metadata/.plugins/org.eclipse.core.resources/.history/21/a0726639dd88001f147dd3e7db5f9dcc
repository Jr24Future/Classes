/*
 *
 *
 */

#include "uart.h"
#include "timer.h"
#include <stdint.h>
#include <stdbool.h>
#include "timer.h"
#include "lcd.h"
#include <inc/tm4c123gh6pm.h>
#include "driverlib/interrupt.h"

#define BIT0 0x01
#define BIT1 0x02
#define BIT2 0x04
#define BIT3 0x08
#define BIT4 0x10
#define BIT5 0x20
#define BIT6 0x40
#define BIT7 0x80

void uart_init(int baud)
{
    SYSCTL_RCGCGPIO_R |= 0b000010;          // enable clock GPIOB (page 340)
    SYSCTL_RCGCUART_R |= 0b00000010;              // enable clock UART1 (page 344)
    GPIO_PORTB_AFSEL_R = 0b00000011;        // sets PB0 and PB1 as peripherals (page 671)
    GPIO_PORTB_PCTL_R  = 0x000F;            // pmc0 and pmc1       (page 688)  also refer to page 650
    GPIO_PORTB_DEN_R   = 0b00000011;        // enables pb0 and pb1
    GPIO_PORTB_DIR_R   = 0b00000001;        // sets pb0 as output, pb1 as input

    //compute baud values [UART clock= 16 MHz]
    double fbrd;
    int    ibrd;

    fbrd = 44   //16000000.0 / (16.0 * 115200.0); // page 903 8.68
    ibrd = 8; //8
    //fbrd = double(0.6806 * 64 + 0.5); //0.68

    UART1_CTL_R &= 0xFFFE;          // disable UART1 (page 918)
    UART1_IBRD_R = ibrd;            // write integer portion of BRD to IBRD
    UART1_FBRD_R = fbrd;            // write fractional portion of BRD to FBRD
    UART1_LCRH_R |= 0x0060;            // write serial communication parameters (page 916) * 8bit and no parity (Error maybe)
    UART1_CC_R   = 0x0;             // use system clock as clock source (page 939)
    UART1_CTL_R |= 0xFFFF;      // enable UART1

}

void uart_sendChar(char data)
{
    while(UART1_FR_R & 0x20) // wait until there is room to send data
    {

    }
    UART1_DR_R= data;   // send data


}

char uart_receive(void)
{
    char data = 0;

    while(UART1_FR_R & UART_FR_RXFE)
    {

    }

    data = (char)(UART1_DR_R & 0xFF);
    return data;


}

void uart_sendStr(const char *data)
{
    while(*data != '\0'){

        uart_sendChar(*data);
        data++;
    }

}

// _PART3


void uart_interrupt_init()
{
    // Enable interrupts for receiving bytes through UART1
    //UART1_IM_R |= REPLACE_ME; //enable interrupt on receive - page 924

    // Find the NVIC enable register and bit responsible for UART1 in table 2-9
    // Note: NVIC register descriptions are found in chapter 3.4
    //NVIC_EN0_R |= REPLACE_ME; //enable uart1 interrupts - page 104

    // Find the vector number of UART1 in table 2-9 ! UART1 is 22 from vector number page 104
    //IntRegister(INT_UART1, REPLACE_ME); //give the microcontroller the address of our interrupt handler - page 104 22 is the vector number

}

void uart_interrupt_handler()
{
    // STEP1: Check the Masked Interrup Status

    //STEP2:  Copy the data

    //STEP3:  Clear the interrup

}
