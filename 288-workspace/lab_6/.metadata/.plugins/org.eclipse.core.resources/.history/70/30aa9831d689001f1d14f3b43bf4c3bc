#define _RESET 0
#define _PART1 0
#define _PART2 1
#define _PART3 0
#define BUFFER_SIZE 20

#include "timer.h"
#include "lcd.h"
#include "uart.h"
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "cyBot_Scan.h"
#include "open_interface.h"
#include "movement.h"


volatile char uart_data;
volatile char flag = 0;


int main(void)
{
    uart_init(115200);
    //right_calibration_value = 343000;
    //left_calibration_value = 1340500;
    lcd_init();
    timer_init();
    uart_interrupt_init();
    oi_t *sensor_data = oi_alloc();
    oi_init(sensor_data);


#if _PART1
    lcd_printf("UART Part 1 Test");

    char buffer[20];
    int count = 0;

    while (1)
    {
        char received = uart_receive();

        if (received == '\r' || count == 20)
        {
            buffer[count] = '\0';
            lcd_clear();
            lcd_printf("%s", buffer);
            count = 0;
        }
        else
        {
            buffer[count++] = received;
            lcd_printf("Char: %c\nCount: %d", received, count);
        }
    }

#elif _PART2
    lcd_printf("UART Echo Test");

    while (1)
    {
        char received = uart_receive();
        uart_sendChar(received);

        if (received == '\r')
        {
            uart_sendChar('\n');
        }

        lcd_printf("Received: %c", received);
    }

#elif _PART3
    lcd_printf("UART Interrupt Test");
    char last_displayed = '\0';

    while (1)
       {
           if (flag == 1)
           {
               flag = 0;

               if (uart_data != last_displayed)
               {
                   lcd_clear();
                   lcd_printf("Received: %c", uart_data);
                   last_displayed = uart_data;
               }

               uart_sendChar(uart_data);

               if (uart_data == '\r')
               {
                   uart_sendChar('\n');
               }
           }
       }

#endif

    return 0;
}




/*
#include "uart.h"
#include "timer.h"
#include "lcd.h"
#include "cyBot_Scan.h"
#include "open_interface.h"
#include "movement.h"

#define SCAN_ANGLE_STEP 5   // Angle increment for scanning, change if needed
#define TOTAL_SCAN_ANGLE 180 // 180-degree scan

volatile char uart_data;
volatile char flag;

// Your existing distance and IR calibration arrays
float distances[] = {9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 50};
int ir_values[] = {1499, 1277, 1147, 1087, 987, 955, 919, 877, 842, 833, 803, 795, 779, 751, 731};

float calculate_distance_linear(int raw_ir) {
    int i;
    if (raw_ir >= ir_values[0]) {
        return distances[0];
    }
    if (raw_ir <= ir_values[14]) {
        return distances[14];
    }
    for (i = 0; i < 14; i++) {
        if (raw_ir <= ir_values[i] && raw_ir > ir_values[i + 1]) {
            float slope = (distances[i + 1] - distances[i]) / (ir_values[i + 1] - ir_values[i]);
            return distances[i] + slope * (raw_ir - ir_values[i]);
        }
    }
    return -1;
}

// Perform a 180-degree scan with calibrated IR and PING data
void perform_scan(cyBOT_Scan_t *scanData) {
    char message[100];

    int angle = 0;
    for (angle; angle <= TOTAL_SCAN_ANGLE; angle += SCAN_ANGLE_STEP) {
        cyBOT_Scan(angle, scanData);   // Perform scan at the given angle
        float ir_distance = calculate_distance_linear(scanData->IR_raw_val);
        int ping_distance = scanData->sound_dist;

        // Print data to LCD and send it over UART
        lcd_printf("Angle: %d\nIR: %.2f cm\nPing: %d cm", angle, ir_distance, ping_distance);

        // Send data over UART
        sprintf(message, "Angle: %d, IR: %.2f cm, Ping: %d cm\r\n", angle, ir_distance, ping_distance);
        uart_sendStr(message);

        timer_waitMillis(100); // Small delay between scan points
    }
}

void control_movement(oi_t *sensor_data, char command) {
    switch (command) {
        case 'w':   // Move forward
            move_forward(sensor_data, 50);  // Move forward 50 cm
            break;
        case 's':   // Move backward
            move_backwards(sensor_data, 25);  // Move backward 25 cm
            break;
        case 'a':   // Turn left
            turn_counter_clockwise(sensor_data, 15);  // Turn left 15 degrees
            break;
        case 'd':   // Turn right
            turn_clockwise(sensor_data, 15);  // Turn right 15 degrees
            break;
        default:
            break;
    }
}

int main(void) {
    // Initialize system components
    uart_init(115200);        // Initialize UART for communication
    uart_interrupt_init();    // Set up UART interrupts for receiving commands
    lcd_init();
    timer_init();
    cyBOT_init_Scan(0b0111);  // Initialize sensors for scanning
    oi_t *sensor_data = oi_alloc();
    oi_init(sensor_data);
    cyBOT_Scan_t scanData;

    char last_displayed = '\0';

    while (1) {
        if (flag) {  // Check if a new UART character was received
            flag = 0;  // Clear the flag after reading

            // Display command on LCD and send it over UART
            if (uart_data != last_displayed) {
                lcd_clear();
                lcd_printf("Received: %c", uart_data);
                last_displayed = uart_data;
            }

            // Perform movement if 'w', 'a', 's', 'd' is pressed
            if (uart_data == 'w' || uart_data == 'a' || uart_data == 's' || uart_data == 'd') {
                control_movement(sensor_data, uart_data);
            }

            // If 'm' is pressed, perform a 180-degree scan and display the data
            if (uart_data == 'm') {
                perform_scan(&scanData);
            }

            // If 'q' is pressed, break out of the loop and stop
            if (uart_data == 'q') {
                oi_free(sensor_data);
                break;
            }

            uart_sendChar(uart_data); // Echo the received character

            if (uart_data == '\r') {
                uart_sendChar('\n'); // Send newline after carriage return
            }
        }
    }

    return 0;
}
*/


